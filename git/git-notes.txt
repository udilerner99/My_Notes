Installation
====================

1. https://git-scm.com/
2. https://brew.sh
    brew install git

Config
====================

settings to git deployment can be made on 3 levels:
  1. system   /etc/gitconfig
  2. user     ~/.gitconfig
              $HOME\.gitconfig

  system:   git config --system
  user:     git config --global
  project:  git config

setting git user:
    git config --global user.name "<user name>"
setting git email:
    git config --global user.email "email"
list configurations:
    git config --list

git config is on home folder
  cd ~
  \.gitconfig

editor for git
==============
git config --global core.editor "vim"

git auto completion
====================
auto complete commands file path and branch names
https://github.com/git/git

=> /contrib/completion/git_completion.bash

2 options to save :
  1.raw => copy text to text editor
  2.save to user directory => .bash

mv <file> .git-git_completion

edit ~/.bashsrc or ~/.bash_profile
add <if clause for loading the completion bash>

Initialise project repository
==============================
  - create folder
  - git init


where's git stores its files
============================
after running git init, git will create a .git folder, under this folder all git's files will be place, including for example the config file,
so for example if we'll cat the file:
$ cat config
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
	ignorecase = true
	precomposeunicode = true

we'll see the content of the configuration setting.
all of git's data is stored in this one folder, deleting it will remove git tracking of this folder content completely.

Git commits
===========

1. tell git to add all of the folder content to the repository (git is still not tracking the changes)
  git add .
2. git commit -m "<message>" (all of the changes we'll make to the files that were added will be tracked)

Commit message best practice
============================
  - short single line summary (less than 50 characters)
  - optionally followed by a blank line and a more complete description
  - each line should be less than 72 characters
  - write commit messages in present tense, not past tense
    the reason is that it describe the change, for example "Fix for a bug" or "fixes a bug"  not "fixed a bug"
  - bullet points are usually asterisks or hyphens
  - can add "tracking numbers" from bugs or support request
  - can develop shorthand for the organisation
    "[css,js]"
    "bugfix:"
    "#38405 -"

View the commit log
===================
1. git log

  return a log of all the commit on the project, with the newest entry on the top.

  for exmaple:

      commit 02219a730d306be711503ee14450175fd0f24b6d (HEAD -> master)
      Author: <user + email>
      Date:   Mon Oct 19 09:32:56 2020 +0300

        initial commit

        first line: unique id number of the commit, will help to identify the commit and track it
        second line: username of the committer
        3rd line: date of the commits
        4th line: commit message

2. git log -n <number>
    show number specified of recent messages

3. git log --since=2019-01-01
    will show all commit since the date specified

4. git log --until=2019-01-01
    will show all commit until the date specified

5. git log --author="<author name>"
    will show all committed by specific author , can be any part of the name not the full name

6. git log --grep="<search phrase>"
    will globaly search for regular expersions

Hash values
=============

  - git generatge a checksum for each change set
  - checksum convert data into a simple number
  - same data always equals same checksum
  - changing data would change checksum value
  - git uses SHA-1 hash algorithm to create checksum (40 characters hexadecimal strings(0-9,a-f))

Head pointer
=============

  pointer to tip of current branch in repository, new commits will move pointer (HEAD) to the new commit, the pointer
  points to the HEAD of the repository

  the HEAD is located on the .git folder on the /HEAD file
  showing the file content will show the HEAD pointer reference to a branch

  example:
  sh-3.2$ cd .git
  sh-3.2$ cat HEAD
  ref: refs/heads/<branch name>

  and it's telling us we can find the information in the refs folder under the specific file, showing the content of it will give us the SHA value
  of the commit

  sh-3.2$ cat refs/heads/tess
  035dcc76f72e9e823220e7e5a3b24b2a2d41ad07

  we can also check other pointers files on the heads folder

git status
  will show us the status of our project.
  on which branch we are on, "nothing to commit" will tell us git is synced with our
  project

  "untracked files" will tel us there are files not in the repository, git is not tracking them, including changes and git doesn't
  know anything about them.

  in case of "untracked files" we can use
    git add . for all content on my working folder OR we can use git add <file name> , for adding specific file.

adding changes to a file to the repository is exactly like adding new files,
    git add <file name> <file name>

    then git commit to commit the changes to staging

Viewing changes with diff
=========================

  git diff
    This will show what has changed, on the WORKING folder against the STAGING tree (will not show us what was changed after commit by default)

  git diff --staged
    will show us the difference between staging area and repository

Deleting files
=================

2 methods to delete files:
  1. remove physically from folder by using finder for example, then use
      git rm <file name>
      and then commit the change
  2. just use
      git rm <file name>
      the file is removed using a unix command, it's still in the repository and we can retrieve it from there if needed
      and then commit the change

Renaming and Moving files
=========================
1. once a file in the repository is renamed , git will mark it as old file delete and a new file created
use git add & git rm on the files to add the changes to the repository

now on git status , git will show the files had been renamed (after checking that they were similar)
exmplae:  renamed:    dumm_file.txt -> dumm_file_new.txt

2. use
  git mv <file name> <new file name>

Showing changes
================
git diff
  will show the diffrence between the HEAD and minus one change (rows removed will be marked with minus, rows added will be marked with +)

git diff --color-words
  will show only the words that are diffrent

Stage and Commit shortcut
=========================

git commit -a
  - stages and commits all changes to tracked files
  - does not include untracked files

a commit message can be added
  git commit -am "the commit message"

View previous commits
======================
steps:
  1. use git log to show the log commits , and choose the SHA you need
  2. git show <SHA value>

comparing two historical commits:
  1. git log
  2. git diff <SHA value 1st commit>..<SHA value selected commit to>

  we can also use same with ..HEAD to compare to latest commit

Multi line commit messages
==========================
1. git commit -a (hit return) = > will go to the text editor
2. save and quit

git log --oneline
  will show condense message in one line

Atomic Commits
================

  - small Commits
  - only affect a single aspect
  - easier to understand, to work with and to find bugs
  - improve collaboration


Undo working directory changes
==============================

  undo changes to a file:
    once a file is tracked on repository, and a change had been made, using checkout on the file will undo the change
    git checkout --<file name>

Unstage files
=============
  for uncommiting :
    1. after file was added with change
    2. git reset HEAD <file name>
  and the file will be unstaged

Amend commits
=============
once a commit had been created, git can amend extra commit into the existing commit with the new changes

1. add the changes (git add <file name>)
2. git commit --amend -m "<commit message>"

after committing the message can be changed using : git commit --amend

Retrieve old versions
=====================

  a file can be restored back to previous version.
    1. use git log to show the desired version
    2. using the SHA value, run
      git checkout <SHA value> -- checkout <file name>
    3. commit the change

Removing untracked files
========================

  to remove untracked files from git repository that we don't want git to track with physically removing them, we can use git clean
    1. git clean -n   we'll get a list of files that will be removed from repository
    2. git clean -f will remove the files

Use .gitignoe files
===================

  we can instruct git to ignore specific files and it will not track them, logs or any other that type of files
  1. create a file in project/.gitignore
  2. git will get a list of rules to determine which files to ignore
  3. changes made to ignored files will be ignore by Git

  pattern matching can be used :
    * ? [aeiou][0-9]
    logs/*.txt
  negative experssions
   like ignore all php:  *.php
    don't ignore : !index.php

  ignore all files in a directory with trailing slash
    assests/videos/

  comments
    # this is a comments

  blank lines will be skipped

  what should be ignored:
    -  compiled source code
    - packages and compressed files
    - logs and databases
    - operating system and generated files
    - user uploaded assets (images, pdfs videos)

  git has gitignore template ready to download
    https://github.com/github/gitignore

Removing tracked files from repository
======================================

  if there's a file already being tracked, just adding it to .gitignore will not stop tracking it
  git rm --cached <file name> and file will be stoped from tracking on git without removing it physically

Tracking empty directory
========================

  git ls-tree HEAD : will list all files and directories under the HEAD

  git doesn't track empty directories , there are several methods to set git to track them:
    1. add a .gitkeep file to the directory (touch <folder name>/.gitkeep)

Tree-ish
=========

  a directory containing files and other directories (GIT calls "trees") , a commit is considered a tree-ish, it refers to a tree at the point
  when a commit had been applied.

  it can refer to :
    - SHA-1 Hash
    - HEAD pointer reference
    - Branch reference
    - Tag reference
    - Ancestry

  Ancestry: Parents
    - <SHA-1>^
    - HEAD^
    - master^
    - HEAD~1, HEAD~
    - git show HEAD^

    Ancestry: GrandParents
      - <SHA-1>^^
      - HEAD^^
      - master^^
      - HEAD~2
      - git show HEAD^^

      Ancestry: GreatGrandParents
        - <SHA-1>^^^
        - HEAD^^^
        - master^^^
        - HEAD~3
        - git show HEAD^^^
        - git show HEAD~3

Tree listing
============
  show content of directory inside git

  git ls-tree <tree-ish>

  git help ls-tree

  git ls-tree HEAD
    show tree of HEAD (latest commit), all rows marked as tree are directories, blob are files (binary large objects)
    you can pick one of the trees specified
    git ls-tree HEAD <tree name> : shows the tree object
    git ls-tree HEAD <tree name>/ : will show content of the tree object

Filter the commit log
=====================

    git log -3
    git log --since=<yyyy-mm-dd>
    git log --until="3 days ago"
    git log --after=2.weeks --before=3.days

    git log --author="<user>"

    git log --grep="<text value>"

    git log <SHA-1>..HEAD : shows log from the SHA to HEAD

    showing log only to a specific file in git:
      1. get file from git by : git ls-tree <get the file>
      2. git log <file name> / or <directory>

commit log format
=================

  show statistics about the log changes
    git log --stat

  format can be changed using:
    git log --format=<medium (defualt) | short | oneline | full | fuller | email | raw>

  for oneline without fill SHA use:
    git log --oneline

  to show log as a graph (very useful for multi branched git)
    git log --graph

    git log --graph --all --oneline --decorate

Branches
==============

  - Branches are cheap
      for trying new ideas
      isolate features or section of work
  - one working directory
  - fast context switching

  show all branch
    git branch
    the Asterix symbol current checked out branch

  create branch
    git branch <branch name>

  on .git/HEAD we can see where our HEAD is pointing
    cat .git/HEAD

  to see HEAD refernce per branch we use:
    ls -la .git/refs/heads

  if we'll use git log --oneline
    we can see on which commit the tip of HEAD is pointing, and on which commit each branch is pointing

  switch Branches
    git checkout <branch name>
    we can confirm it if we'll check the .git/HEAD

    if trying to checkout branch and there's a conflict with one of the files, git will not allow us to checkout the branch, will need to resolve
    the conflict.

      - commit the changes to current branch
      - remove the change, checkout the file again
      - stash the changes
