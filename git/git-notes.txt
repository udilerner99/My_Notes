Installation
====================

1. https://git-scm.com/
2. https://brew.sh
    brew install git

Config
====================

settings to git deployment can be made on 3 levels:
  1. system   /etc/gitconfig
  2. user     ~/.gitconfig
              $HOME\.gitconfig

  system:   git config --system
  user:     git config --global
  project:  git config

setting git user:
    git config --global user.name "<user name>"
setting git email:
    git config --global user.email "email"
list configurations:
    git config --list

git config is on home folder
  cd ~
  \.gitconfig

editor for git
==============
git config --global core.editor "vim"

git auto completion
====================
auto complete commands file path and branch names
https://github.com/git/git

=> /contrib/completion/git_completion.bash

2 options to save :
  1.raw => copy text to text editor
  2.save to user directory => .bash

mv <file> .git-git_completion

edit ~/.bashsrc or ~/.bash_profile
add <if clause for loading the completion bash>

Initialise project repository
==============================
  - create folder
  - git init


where's git stores its files
============================
after running git init, git will create a .git folder, under this folder all git's files will be place, including for example the config file,
so for example if we'll cat the file:
$ cat config
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
	ignorecase = true
	precomposeunicode = true

we'll see the content of the configuration setting.
all of git's data is stored in this one folder, deleting it will remove git tracking of this folder content completely.

Git commits
===========

1. tell git to add all of the folder content to the repository (git is still not tracking the changes)
  git add .
2. git commit -m "<message>" (all of the changes we'll make to the files that were added will be tracked)

Commit message best practice
============================
  - short single line summary (less than 50 characters)
  - optionally followed by a blank line and a more complete description
  - each line should be less than 72 characters
  - write commit messages in present tense, not past tense
    the reason is that it describe the change, for example "Fix for a bug" or "fixes a bug"  not "fixed a bug"
  - bullet points are usually asterisks or hyphens
  - can add "tracking numbers" from bugs or support request
  - can develop shorthand for the organisation
    "[css,js]"
    "bugfix:"
    "#38405 -"

View the commit log
===================
1. git log

  return a log of all the commit on the project, with the newest entry on the top.

  for exmaple:

      commit 02219a730d306be711503ee14450175fd0f24b6d (HEAD -> master)
      Author: <user + email>
      Date:   Mon Oct 19 09:32:56 2020 +0300

        initial commit

        first line: unique id number of the commit, will help to identify the commit and track it
        second line: username of the committer
        3rd line: date of the commits
        4th line: commit message

2. git log -n <number>
    show number specified of recent messages

3. git log --since=2019-01-01
    will show all commit since the date specified

4. git log --until=2019-01-01
    will show all commit until the date specified

5. git log --author="<author name>"
    will show all committed by specific author , can be any part of the name not the full name

6. git log --grep="<search phrase>"
    will globaly search for regular expersions

Hash values
=============

  - git generatge a checksum for each change set
  - checksum convert data into a simple number
  - same data always equals same checksum
  - changing data would change checksum value
  - git uses SHA-1 hash algorithm to create checksum (40 characters hexadecimal strings(0-9,a-f))

Head pointer
=============

  pointer to tip of current branch in repository, new commits will move pointer (HEAD) to the new commit, the pointer
  points to the HEAD of the repository

  the HEAD is located on the .git folder on the /HEAD file
  showing the file content will show the HEAD pointer reference to a branch

  example:
  sh-3.2$ cd .git
  sh-3.2$ cat HEAD
  ref: refs/heads/<branch name>

  and it's telling us we can find the information in the refs folder under the specific file, showing the content of it will give us the SHA value
  of the commit

  sh-3.2$ cat refs/heads/tess
  035dcc76f72e9e823220e7e5a3b24b2a2d41ad07

  we can also check other pointers files on the heads folder

git status
  will show us the status of our project.
  on which branch we are on, "nothing to commit" will tell us git is synced with our
  project

  "untracked files" will tel us there are files not in the repository, git is not tracking them, including changes and git doesn't
  know anything about them.

  in case of "untracked files" we can use
    git add . for all content on my working folder OR we can use git add <file name> , for adding specific file.

adding changes to a file to the repository is exactly like adding new files,
    git add <file name> <file name>

    then git commit to commit the changes to staging

Viewing changes with diff
=========================

  git diff
    This will show what has changed, on the WORKING folder against the STAGING tree (will not show us what was changed after commit by default)

  git diff --staged
    will show us the difference between staging area and repository

Deleting files
=================

2 methods to delete files:
  1. remove physically from folder by using finder for example, then use
      git rm <file name>
      and then commit the change
  2. just use
      git rm <file name>
      the file is removed using a unix command, it's still in the repository and we can retrieve it from there if needed
      and then commit the change

Renaming and Moving files
=========================
1. once a file in the repository is renamed , git will mark it as old file delete and a new file created
use git add & git rm on the files to add the changes to the repository

now on git status , git will show the files had been renamed (after checking that they were similar)
exmplae:  renamed:    dumm_file.txt -> dumm_file_new.txt

2. use
  git mv <file name> <new file name>

Showing changes
================
git diff
  will show the diffrence between the HEAD and minus one change (rows removed will be marked with minus, rows added will be marked with +)

git diff --color-words
  will show only the words that are diffrent

Stage and Commit shortcut
=========================

git commit -a
  - stages and commits all changes to tracked files
  - does not include untracked files

a commit message can be added
  git commit -am "the commit message"

View previous commits
======================
steps:
  1. use git log to show the log commits , and choose the SHA you need
  2. git show <SHA value>

comparing two historical commits:
  1. git log
  2. git diff <SHA value 1st commit>..<SHA value selected commit to>

  we can also use same with ..HEAD to compare to latest commit

Multi line commit messages
==========================
1. git commit -a (hit return) = > will go to the text editor
2. save and quit

git log --oneline
  will show condense message in one line

Atomic Commits
================

  - small Commits
  - only affect a single aspect
  - easier to understand, to work with and to find bugs
  - improve collaboration
